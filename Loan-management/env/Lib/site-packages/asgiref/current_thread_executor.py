import queue
import threading
from concurrent.futures import Executor, Future


class _Task:
    """
    Represents a task to be executed by the executor.
    Equivalent in purpose to ThreadPoolExecutor's internal WorkItem.
    """

    def __init__(self, future: Future, fn, args, kwargs):
        self.future = future
        self.fn = fn
        self.args = args
        self.kwargs = kwargs

    def run(self):
        """Execute the stored function and set the result or exception on the future."""
        if not self.future.set_running_or_notify_cancel():
            return
        try:
            result = self.fn(*self.args, **self.kwargs)
        except BaseException as exc:
            self.future.set_exception(exc)
            self = None  # Break potential reference cycle
        else:
            self.future.set_result(result)


class CurrentThreadExecutor(Executor):
    """
    Executor that runs code synchronously in the thread it was created.
    Useful for running sync code from async threads.
    """

    def __init__(self):
        self._origin_thread = threading.current_thread()
        self._task_queue = queue.Queue()
        self._stopped = False

    def run_until_future(self, future: Future):
        """
        Run queued tasks until the specified future is complete.
        Must be called from the same thread where the executor was created.
        """
        if threading.current_thread() != self._origin_thread:
            raise RuntimeError("Cannot run CurrentThreadExecutor from another thread")

        future.add_done_callback(self._task_queue.put)

        try:
            while True:
                task = self._task_queue.get()
                if task is future:
                    return
                task.run()
                del task
        finally:
            self._stopped = True

    def submit(self, fn, *args, **kwargs):
        """
        Schedule a function to be executed.
        Returns a Future representing the execution.
        """
        if threading.current_thread() == self._origin_thread:
            raise RuntimeError(
                "Cannot submit tasks from the executorâ€™s own thread"
            )
        if self._stopped:
            raise RuntimeError("Executor already stopped or broken")

        future = Future()
        task = _Task(future, fn, args, kwargs)
        self._task_queue.put(task)
        return future
