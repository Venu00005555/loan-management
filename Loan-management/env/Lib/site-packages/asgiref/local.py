import random
import string
import sys
import threading
import weakref


class Local:
    """
    Thread/task-local storage compatible with both async and sync contexts.
    """

    CLEANUP_INTERVAL = 60  # seconds

    def __init__(self, thread_critical: bool = False) -> None:
        self._thread_critical = thread_critical
        self._lock = threading.RLock()
        self._contexts = weakref.WeakSet()
        # Unique name to avoid accidental reuse
        suffix = "".join(random.choice(string.ascii_letters) for _ in range(8))
        self._attr_name = f"_asgiref_local_impl_{id(self)}_{suffix}"

    def _get_context_id(self):
        """Identify current async task or thread context."""
        from .sync import AsyncToSync, SyncToAsync  # Avoid circular import

        context = SyncToAsync.get_current_task()
        is_async = True

        if context is None:
            context = threading.current_thread()
            is_async = False

        if self._thread_critical:
            return context

        # Resolve task-thread relationships across sync/async boundaries
        for _ in range(sys.getrecursionlimit()):
            try:
                if is_async:
                    context = AsyncToSync.launch_map[context]
                    is_async = False
                else:
                    context = SyncToAsync.launch_map[context]
                    is_async = True
            except KeyError:
                break
        else:
            raise RuntimeError("Infinite launch_map loop detected")

        return context

    def _get_storage(self):
        context = self._get_context_id()
        if not hasattr(context, self._attr_name):
            setattr(context, self._attr_name, {})
            self._contexts.add(context)
        return getattr(context, self._attr_name)

    def __del__(self):
        try:
            for context in self._contexts:
                try:
                    delattr(context, self._attr_name)
                except AttributeError:
                    pass
        except TypeError:
            # Happens when Python is shutting down
            pass

    def __getattr__(self, key):
        with self._lock:
            storage = self._get_storage()
            if key in storage:
                return storage[key]
            raise AttributeError(f"{self!r} has no attribute {key!r}")

    def __setattr__(self, key, value):
        if key in ("_contexts", "_thread_critical", "_lock", "_attr_name"):
            return super().__setattr__(key, value)
        with self._lock:
            storage = self._get_storage()
            storage[key] = value

    def __delattr__(self, key):
        with self._lock:
            storage = self._get_storage()
            if key in storage:
                del storage[key]
            else:
                raise AttributeError(f"{self!r} has no attribute {key!r}")
