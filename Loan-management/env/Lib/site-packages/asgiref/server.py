import asyncio
import logging
import time
import traceback

from .compatibility import get_running_loop, guarantee_single_callable, run_future

logger = logging.getLogger(__name__)


class StatelessServer:
    """A lightweight, stateless ASGI server framework base."""

    CHECK_INTERVAL = 0.1  # seconds between app cleanup checks

    def __init__(self, application, max_applications=1000):
        self.application = application
        self.max_applications = max_applications
        self.instances = {}

    # -------------------------------
    # Event loop and lifecycle
    # -------------------------------
    def run(self):
        """Run the event loop with the application handler."""
        loop = get_running_loop()
        asyncio.ensure_future(self._check_applications())
        try:
            loop.run_until_complete(self.handle())
        except KeyboardInterrupt:
            logger.info("Server stopped (KeyboardInterrupt)")

    async def handle(self):
        """Subclasses must override this to handle incoming events."""
        raise NotImplementedError("Subclasses must implement handle()")

    async def application_send(self, scope, message):
        """Subclasses must override to process app output."""
        raise NotImplementedError("Subclasses must implement application_send()")

    # -------------------------------
    # Application instance management
    # -------------------------------
    def get_or_create_instance(self, scope_id, scope):
        """Create or retrieve an existing app instance for the given scope."""
        if scope_id in self.instances:
            self.instances[scope_id]["last_used"] = time.time()
            return self.instances[scope_id]["queue"]

        # Limit the number of active instances
        while len(self.instances) > self.max_applications:
            self._remove_oldest_instance()

        queue = asyncio.Queue()
        app = guarantee_single_callable(self.application)

        future = run_future(
            app(
                scope=scope,
                receive=queue.get,
                send=lambda msg: self.application_send(scope, msg),
            )
        )

        self.instances[scope_id] = {
            "queue": queue,
            "future": future,
            "scope": scope,
            "last_used": time.time(),
        }
        return queue

    def _remove_oldest_instance(self):
        """Remove the least recently used app instance."""
        oldest_scope = min(
            self.instances, key=lambda sid: self.instances[sid]["last_used"]
        )
        self._delete_instance(oldest_scope)

    def _delete_instance(self, scope_id):
        """Cancel and remove a running application instance."""
        details = self.instances.pop(scope_id, None)
        if details and not details["future"].done():
            details["future"].cancel()

    # -------------------------------
    # Application lifecycle monitoring
    # -------------------------------
    async def _check_applications(self):
        """Periodically clean up finished app instances and log exceptions."""
        while True:
            await asyncio.sleep(self.CHECK_INTERVAL)
            for scope_id, details in list(self.instances.items()):
                if details["future"].done():
                    exc = details["future"].exception()
                    if exc:
                        await self._handle_exception(exc, details)
                    self.instances.pop(scope_id, None)

    async def _handle_exception(self, exc, details):
        """Log application-level exceptions."""
        logger.error(
            "Exception in application:\n%s\n%s%s",
            exc,
            "".join(traceback.format_tb(exc.__traceback__)),
            f"  {exc}",
        )
