import asyncio
import time

from .compatibility import guarantee_single_callable
from .timeout import timeout as async_timeout


class ApplicationCommunicator:
    """Handles async communication between an ASGI application and test client."""

    def __init__(self, application, scope):
        self.application = guarantee_single_callable(application)
        self.scope = scope
        self._input = asyncio.Queue()
        self._output = asyncio.Queue()
        self._task = asyncio.ensure_future(
            self.application(scope, self._input.get, self._output.put)
        )

    async def wait(self, timeout=1):
        """Wait for the application to finish or cancel it after timeout."""
        try:
            async with async_timeout(timeout):
                try:
                    await self._task
                    self._task.result()
                except asyncio.CancelledError:
                    pass
        finally:
            if not self._task.done():
                self._task.cancel()
                try:
                    await self._task
                except asyncio.CancelledError:
                    pass

    def stop(self, raise_exceptions=True):
        """Stop the application task, optionally raising any stored exceptions."""
        if not self._task.done():
            self._task.cancel()
        elif raise_exceptions:
            self._task.result()

    def __del__(self):
        """Ensure cleanup on object deletion."""
        try:
            self.stop(raise_exceptions=False)
        except RuntimeError:
            # Event loop might already be closed
            pass

    async def send_input(self, message):
        """Send a message into the application."""
        await self._input.put(message)

    async def receive_output(self, timeout=1):
        """Receive a message from the application, with timeout handling."""
        if self._task.done():
            self._task.result()

        try:
            async with async_timeout(timeout):
                return await self._output.get()
        except asyncio.TimeoutError as e:
            if self._task.done():
                self._task.result()
            else:
                self._task.cancel()
                try:
                    await self._task
                except asyncio.CancelledError:
                    pass
            raise e

    async def receive_nothing(self, timeout=0.1, interval=0.01):
        """Check that no output was produced within a given timeout."""
        start_time = time.monotonic()
        while time.monotonic() - start_time < timeout:
            if not self._output.empty():
                return False
            await asyncio.sleep(interval)
        return self._output.empty()
