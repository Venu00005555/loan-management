# This code is originally sourced from the aio-libs project "async_timeout",
# under the Apache 2.0 license. You may see the original project at
# https://github.com/aio-libs/async-timeout

# It is vendored here to reduce chain-dependencies on this library, and
# modified slightly to remove some features we don't use.


import asyncio
import sys
from types import TracebackType
from typing import Any, Optional, Type


class Timeout:
    """
    Async context manager for handling timeouts in asyncio tasks.
    Works the same as the original 'timeout' class, but cleaner and clearer.
    """

    def __init__(self, timeout: Optional[float], *, loop: Optional[asyncio.AbstractEventLoop] = None) -> None:
        self._timeout = timeout
        self._loop = loop or asyncio.get_event_loop()
        self._task: Optional[asyncio.Task[Any]] = None
        self._cancelled = False
        self._cancel_handler: Optional[asyncio.Handle] = None
        self._cancel_at: Optional[float] = None

    # ---------- Context Manager Entry/Exit ---------- #

    def __enter__(self) -> "Timeout":
        return self._enter_sync()

    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> Optional[bool]:
        self._exit_sync(exc_type)
        return None

    async def __aenter__(self) -> "Timeout":
        return self._enter_sync()

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> None:
        self._exit_sync(exc_type)

    # ---------- Properties ---------- #

    @property
    def expired(self) -> bool:
        """Return True if timeout has expired."""
        return self._cancelled

    @property
    def remaining(self) -> Optional[float]:
        """Return remaining time before timeout expires."""
        if self._cancel_at is None:
            return None
        return max(self._cancel_at - self._loop.time(), 0.0)

    # ---------- Internal Logic ---------- #

    def _enter_sync(self) -> "Timeout":
        """Enter the timeout context."""
        if self._timeout is None:
            return self

        self._task = get_current_task(self._loop)
        if self._task is None:
            raise RuntimeError("Timeout context manager must be used inside an asyncio task")

        # Handle zero or negative timeout immediately
        if self._timeout <= 0:
            self._loop.call_soon(self._cancel_task)
            return self

        # Schedule cancellation
        self._cancel_at = self._loop.time() + self._timeout
        self._cancel_handler = self._loop.call_at(self._cancel_at, self._cancel_task)
        return self

    def _exit_sync(self, exc_type: Optional[Type[BaseException]]) -> None:
        """Exit the timeout context."""
        if exc_type is asyncio.CancelledError and self._cancelled:
            # The task was cancelled by timeout
            self._clear()
            raise asyncio.TimeoutError

        # Cancel pending timeout handler
        if self._cancel_handler is not None:
            self._cancel_handler.cancel()
        self._clear()

    def _cancel_task(self) -> None:
        """Cancel the running task when timeout expires."""
        if self._task:
            self._task.cancel()
            self._cancelled = True

    def _clear(self) -> None:
        """Clean up internal state."""
        self._cancel_handler = None
        self._task = None


def get_current_task(loop: asyncio.AbstractEventLoop) -> Optional["asyncio.Task[Any]"]:
    """
    Cross-version compatible way to get the current asyncio Task.
    """
    if sys.version_info >= (3, 7):
        task = asyncio.current_task(loop=loop)
    else:
        task = asyncio.Task.current_task(loop=loop)

    # Fallback for legacy event loop implementations
    if task is None and hasattr(loop, "current_task"):
        task = loop.current_task()

    return task
