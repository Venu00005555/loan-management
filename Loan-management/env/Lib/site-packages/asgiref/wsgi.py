from io import BytesIO
from tempfile import SpooledTemporaryFile
from asgiref.sync import AsyncToSync, sync_to_async


class WsgiToAsgi:
    """
    Adapter that allows a traditional WSGI app to run in an ASGI server.
    """

    def __init__(self, app):
        self.app = app

    async def __call__(self, scope, receive, send):
        """
        ASGI entry point. Creates and runs a handler for this connection.
        """
        handler = _WsgiConnectionHandler(self.app)
        await handler.handle(scope, receive, send)


class _WsgiConnectionHandler:
    """
    Handles one ASGI connection, translating between ASGI and WSGI protocols.
    """

    def __init__(self, app):
        self.app = app
        self.scope = None
        self._headers_sent = False
        self._content_length = None
        self._sync_send = None

    async def handle(self, scope, receive, send):
        if scope.get("type") != "http":
            raise ValueError("WsgiToAsgi only supports HTTP scopes")

        self.scope = scope
        self._sync_send = AsyncToSync(send)

        with SpooledTemporaryFile(max_size=65536) as body:
            # Collect the full HTTP request body
            while True:
                event = await receive()
                if event["type"] != "http.request":
                    raise ValueError("Unexpected message type in WSGI adapter")

                body.write(event.get("body", b""))
                if not event.get("more_body", False):
                    break

            body.seek(0)
            await self._execute_wsgi(body)

    def _create_environ(self, body):
        """
        Builds a WSGI environ dict from ASGI scope and body.
        """
        scope = self.scope
        environ = {
            "REQUEST_METHOD": scope["method"],
            "SCRIPT_NAME": scope.get("root_path", ""),
            "PATH_INFO": scope["path"],
            "QUERY_STRING": scope["query_string"].decode("ascii"),
            "SERVER_PROTOCOL": f"HTTP/{scope['http_version']}",
            "wsgi.version": (1, 0),
            "wsgi.url_scheme": scope.get("scheme", "http"),
            "wsgi.input": body,
            "wsgi.errors": BytesIO(),
            "wsgi.multithread": True,
            "wsgi.multiprocess": True,
            "wsgi.run_once": False,
        }

        server = scope.get("server", ("localhost", 80))
        environ["SERVER_NAME"], environ["SERVER_PORT"] = server[0], str(server[1])

        if "client" in scope:
            environ["REMOTE_ADDR"] = scope["client"][0]

        for name, value in scope.get("headers", []):
            name_str = name.decode("latin1")
            value_str = value.decode("latin1")
            key = (
                "CONTENT_LENGTH" if name_str == "content-length"
                else "CONTENT_TYPE" if name_str == "content-type"
                else f"HTTP_{name_str.upper().replace('-', '_')}"
            )
            if key in environ:
                environ[key] += f",{value_str}"
            else:
                environ[key] = value_str

        return environ

    def _start_response(self, status, headers, exc_info=None):
        """
        Implements the WSGI start_response callable.
        """
        if self._headers_sent:
            raise exc_info[1].with_traceback(exc_info[2])

        if hasattr(self, "_response_start") and exc_info is None:
            raise ValueError("start_response called twice without exc_info")

        code = int(status.split(" ", 1)[0])
        encoded_headers = [
            (n.lower().encode("ascii"), v.encode("ascii")) for n, v in headers
        ]

        self._content_length = next(
            (int(v) for n, v in headers if n.lower() == "content-length"),
            None,
        )

        self._response_start = {
            "type": "http.response.start",
            "status": code,
            "headers": encoded_headers,
        }

    @sync_to_async
    def _execute_wsgi(self, body):
        """
        Runs the WSGI app synchronously and streams results to ASGI.
        """
        environ = self._create_environ(body)
        bytes_sent = 0

        for chunk in self.app(environ, self._start_response):
            if not self._headers_sent:
                self._headers_sent = True
                self._sync_send(self._response_start)

            if self._content_length is not None:
                remaining = self._content_length - bytes_sent
                if len(chunk) > remaining:
                    chunk = chunk[:remaining]

            self._sync_send({
                "type": "http.response.body",
                "body": chunk,
                "more_body": True,
            })
            bytes_sent += len(chunk)

            if self._content_length and bytes_sent >= self._content_length:
                break

        if not self._headers_sent:
            self._headers_sent = True
            self._sync_send(self._response_start)

        self._sync_send({"type": "http.response.body"})
